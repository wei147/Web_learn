<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lesson 12</title>
    <script src="https://unpkg.com/vue@next"></script>
</head>

<body>
    <div id="wei">
        <h4>{{message}}</h4>
    </div>
</body>

<script>
    // 事件修饰符:stop,prevent,capture,self,once,passive
    //案件修饰符
    const app = Vue.createApp({
        data() {
            return {
                message: '冰红茶 yooo',
                counter: 0
            }
        },
        methods: {
            //接收event事件
            handleBtnClick(num, event) {
                // console.log(event);
                // console.log(event.target);
                // this.counter = this.counter + num;
                // this.counter += 1;
                this.counter = this.counter+1
                // alert(1)
            },
            handleBtnClick1(event) {
                // alert(2)
            },

            handleDivClick(event) {
                alert("这是div")
            }
        },

        template: `
        <hr>
        <div @click.once="handleDivClick()">
            // <a href="www.baidu.com">百度</a>
            <h4>{{counter}}</h4>
        <button @click="handleBtnClick(2,$event),handleBtnClick1()">点击</button>
        </div>
            `
        // <button @click="counter +=1">点击</button> 也可以直接这样写。实现counter+1
        // 如果我们要额外传递参数同时要要获取到原生的事件对象的话,可以这样写  @click="handleBtnClick(2,$event)
        //点击事件的冒泡。点击div里面的btn,btn会先做出响应,然后会冒泡到div
        //怎么停止冒泡? @click.stop停止向外做事件的冒泡
        // @click.self 会做一个判断。只有点击到自己的时候,才会触发(必须是点击到自己的这个dom标签才会触发,子标签触发的dom事件不会执行),
        //@click.prevent 阻止默认行为。加上之后,比如a标签的跳转就不支持了
        //@click.capture 把事件的运营模式变成捕获(默认是冒泡,冒泡是由内到外,捕获时从外到内)
        //@click.once只执行一次函数
    });
    const vm = app.mount("#wei");
</script>

</html>